# JSONator
JSONator is a type-safe header-only library for C++. It is intended to be a minimalistic library that supports multi-type arrays and objects, along with a handful of other useful features.

## Installation
Simply store the jsonator.h file on your computer and add it to your projects dependencies in your IDE.

## Usage
```C++
#include <jsonator>
#include <iostream>

using namespace JSONator;

int main()
{
    // JSON objects are created with parse(). You can create your own with a string literal or give it text
    // generated by another function. Whitespace doesn't matter but be mindful of syntax errors.
    std::string primitive_test = "{ int : 111, double : 1.332, bool : false, string : \"Hello World!\" }";

    // Here we create a JSON object and initialize it with parse().
    // If the parser finds syntax errors it can't reslove it will return an empty object.
    JSON obj1 = JSON::parse(primitive_test);
    
    // Check to make sure the object is not empty
    bool b = obj1.is_empty();
    std::cout << b << std::endl; // output: false

    // Data is extracted from the object by using a return function. Each type has a separate return function.
    // You must specify the 'path' to the key-value pair that you wish to access with the an() and dn() functions.
    // These approximate array and dot notation since c++ does not allow those operators to be overloaded.
    // an() takes an integer to specify the index (zero indexed) and dn() takes a string specifying the key.
    int a = JSON::r_int(obj1.dn("int"));
    double b = JSON::r_double(obj1.dn("double"));
    bool c = JSON::r_bool(obj1.dn("bool"));
    std::string d = JSON::r_string(obj1.dn("string"));

    std::cout << a << std::endl; // output: 111
    std::cout << b << std::endl; // output: 1.332
    std::cout << c << std::endl; // output: 0
    std::cout << d << std::endl; // output: "Hello World!"

    // An array can contain multiple types as well. Note that dn() and an() are chained together to create
    // a path to the desired value.
    std::string array_test = "{ array : [1, 2, \"word\"] }";
    JSON obj2 = JSON::parse(array_test);
    int e = JSON::r_int(obj2.dn("array").an(1));

    std::cout << e << std::endl; // output: 2

    // Use dn() to access nested objects
    std::string object_test = "{ object : { nestedKey: \"nestedValue\", anotherArray : [123, true, 1.443] } }";
    JSON obj3 = JSON::parse(object_test);

    int f = JSON::r_int(obj3.dn("object").dn("anotherArray").an(0));
    std::cout << f << std::endl; // output: 123
}
```

You can also update the values stored in the JSON object:

```C++
#include <jsonator>
#include <iostream>

using namespace JSONator;

int main()
{
    // Set up the object as before...
    std::string primitive_test = "{ int : 111, double : 1.332, bool : false, string : \"Hello World!\" }";
    JSON obj1 = JSON::parse(primitive_test);

    int a = JSON::r_int(obj1.dn("int"));
    double b = JSON::r_double(obj1.dn("double"));
    bool c = JSON::r_bool(obj1.dn("bool"));
    std::string d = JSON::r_string(obj1.dn("string"));

    std::cout << a << std::endl; // output: 111
    std::cout << b << std::endl; // output: 1.332
    std::cout << c << std::endl; // output: 0
    std::cout << d << std::endl; // output: "Hello World!"

    // Now we can call update_value() on each key in the JSON object
    JSON::update_value(222, obj1.dn("int"));
    JSON::update_value(5.443, obj1.dn("double"));
    JSON::update_value(true, obj1.dn("bool"));
    JSON::update_value(std::string("Hello!"), obj1.dn("string"));

    // Retrieve the values again
    a = JSON::r_int(obj1.dn("int"));
    b = JSON::r_double(obj1.dn("double"));
    c = JSON::r_bool(obj1.dn("bool"));
    d = JSON::r_string(obj1.dn("string"));

    // And the values have been updated!
    std::cout << a << std::endl; // output: 222
    std::cout << b << std::endl; // output: 5.443
    std::cout << c << std::endl; // output: 1
    std::cout << d << std::endl; // output: "Hello!"

    // We can also update the keys
    JSON::update_key("new_key", obj1.dn("int"));
    int e = JSON::r_int(obj1.dn("new_key"));

    std::cout << e << std::endl; // ouput: 222
}
```

Key-value pairs and array contents can be deleted:

```C++
#include "jsonator.h"
#include <iostream>

using namespace JSONator;

int main()
{
    // Set up the object as before...
    std::string object_test = "{ object : { nestedKey: \"nestedValue\", anotherArray : [123, true, 1.443] } }";
    JSON obj1 = JSON::parse(object_test);

    int a = JSON::r_int(obj1.dn("object").dn("anotherArray").an(0));
    std::cout << a << std::endl; // output: 123

    // Here we use remove_from_object to delete a key-value pair
    JSON::remove_from_object(obj1.dn("object"), "anotherArray");
    
    // r_int returns -1 if the requested path is empty or not found
    a = JSON::r_int(obj1.dn("object").dn("anotherArray").an(0));
    std::cout << a << std::endl; // output: -1

    obj1 = JSON::parse(object_test); // reset the object

    // We can also remove a value from an array
    JSON::remove_from_array(obj1.dn("object").dn("anotherArray"), 1);
    
    // r_bool returns false if the requested path is empty or not found
    bool b = JSON::r_bool(obj1.dn("object").dn("anotherArray").an(1));
    std::cout << b << std::endl; // output: 0

    // Alternatively we can search the entire data structure and remove the first key-value pair
    // that matches a given key.
    obj1.remove_first_found("nestedKey");
    std::string s = JSON::r_string(obj1.dn("object").dn("nestedKey"));
    
    // r_string returns an empty string if the requested path is empty or not found
    int c = s.size();
    std::cout << c << std::endl; // output: 0
}
```

And finally after making changes to the data structure we can serialize it:

```C++
#include "jsonator.h"
#include <iostream>

using namespace JSONator;

int main()
{
    // Set up the object as before...
    std::string primitive_test = "{ int : 111, double : 1.332, bool : false, string : \"Hello World!\" }";
    JSON obj1 = JSON::parse(primitive_test);

    // Changing the values...
    JSON::update_value(222, obj1.dn("int"));
    JSON::update_value(5.443, obj1.dn("double"));
    JSON::update_value(true, obj1.dn("bool"));
    JSON::update_value(std::string("Hello!"), obj1.dn("string"));

    std::string s = JSON::serialize(obj1);
    std::cout << s << std::endl; // output: {int : 222, double : 5.443000, bool : 1, string : \"Hello!\"}
}
```

## License

JSONator
Copyright (c) 2022 Cameron White

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
